{"pages":[{"url":"https://blog.yoitsu.moe/zhao-bu-dao-wen-zhang.html","text":"咱找不到汝需要的页面呐~ 如果汝是点击页面中的链接来到这里的话，发个评论给咱让咱修复链接呗~ 如果汝是随意输入URL的话，或许想查看 存档 ？如果有啥想法的话，也可以和咱说呐~","tags":"pages","title":"找不到文章"},{"url":"https://blog.yoitsu.moe/links.html","text":"因为有伙伴们在，咱就不是孤独一人呐~ 下面的链接列表以结识的区域分类，排名不分先后。如果汝想和咱结交的话， 来这看看呗~ IRC 频道 #archlinux-cn farseerfc 正在日本就读的博士生一枚，Arch Linux TU（授信用户，维护官方软件仓库的一群人）一名，同时是个人生赢家😂 lilydjwg 依云 #archlinuxcn 社区管理者之一，美味或流浪的坚持用XMPP的百合仙子。 phoenixlzx 凤凰卷 #archlinuxcn 社区管理者之一，好吃的凤凰卷兼 #nyaacat MC喵窝 管理员之一。 LastAvengers 谷月轩 社区里人称LA，一个 自己写了内核 而且会画画的 一个恶人 ~ felixonmars 人称肥猫，Arch Linux中文社区网站的维护者之一+Arch Linux TU+刷包狂人（雾）+撑起了Arch Linux半壁江山的领袖（超大雾 御宅暴君 acgtyrant 身兼聽力殘疾，一直立身力行地一日三省，口風相當緊，中文審美嚴苛無比，計算機科學絕讚登堂中，批判性思維異常過人，完美無瑕之守序中立，偶尔飙中二腔，大愛 ACG 與 Arch Linux. LQYMGT #archlinux-cn 中的偶像，.sm 最多的人。 quininer U need tox （雾） ，小心Ta傲娇block汝呐~（大雾），写着一个JavaScript驱动的帅气博客。（没雾） Frantic1048 Chino Kafuu 智乃 香风 萌萌的智乃，自己很萌的同时喜欢一切萌物，前端技艺精湛，貌似正在构建新的博客框架…… Cuihao 崔灏 因为 灏 ( hao,四声 ) 的缘故经常被唤作崔土豪,曾经是 USTC镜像源 的维护者, 现在是 Arch Linux 中文社区源的维护者之一. IRC 频道 #aosc (Telegram群 \"安同开源社区\"，目前不开放~） 白铭骢 Jeff Bai AOSC创始人 兼特首 ,开源爱好者：打包狂人，翻译狂魔，FSF 会员. Azu | Nyan Skidmore College （准）学生，伪宅。折腾是生命的动力。千万别以为Ta是开发者或者什么别的技术人才，这是不正确的。 Mingye Wang / 王铭烨 一个野生逗比小学生、间歇性自由软件原教旨主义者，并且他忽悠了很多人，很多很多人。 （因为某些特殊原因在某QQ群被调教，并被备注为女装狂魔） Telegram群 MediaWiki 站长交流 冼睿通 Pumiao 逗比+滑稽一枚。（咱想不到该说啥了嘛~） 李坤严（夏日大三角） 工作于中国厦门，从事IT行业，做过运维、程序员（PHP+MySQL+SDK），下班除了生活，喜欢搞鼓VPS（Linux），还有开源软件，比如 MediaWiki，Etherpad，Seafile，以及一些小应用。 Ruqi Li MediaWiki站长交流Telegram群里第三个说话的人（第一个是咱，第二个是@Pumiao（滑稽）） 地点不明（准确的地点咱已经忘记了呐~） 编程随想的博客 一个不知道是谁的博客，只知道他（她）是个程序员（媛）。原来写了些编程相关的博文，后来也开始传授一些网络安全相关的技巧，偶尔也分享些电子书。 Xiaolan （蓝潇） 如同博主本人所说，没什么特别的主题，想到什么写什么.... FiveYellowMice 一位早就不该中二的中二少年，最近又开了一个脑洞，于是就开了这个博客。","tags":"pages","title":"友情链接"},{"url":"https://blog.yoitsu.moe/addlinks.html","text":"首先咱问友情链接有啥用处的时候，一般都会得到这样的回答： 听说这样可以提升网站的 PageRank|PageRank ，在搜索结果中靠前——专业的讲，就是 SEO 。 — FiveYellowMice's Blog 友情链接的坏处是啥咧~ 那就是会让网页看起来比较乱，具体的例子咱就不举例了。另外页面下一排链接看着也不好看是呗~ 关键的原因是，咱比较懒嘛~ 那这个页面是来干啥的呢？ 因为既然交换了友情链接嘛，他（她/它）们就要把咱的地址放在网站上，访问那些网站的人们或许会来看咱呐~ 同样也可以让别人的博客通过咱这里的友情链接被发现。友情链接就这样被用来传递友情，而非 PageRank 。 交换友情链接的最低要求 下列类型的网站会直接拒绝的呐~ 教唆犯罪（可不是某国的口袋罪哟~）：例如关于帮助非法药品使用、盗窃、网络入侵、创建恶意代码、禁止的软件拷贝、禁止使用的版权/专利材料、破解软件(warez)，以及提供这些内容的种子(torrent)或链接的网站。 单纯的采集（说的难听些就是抄袭）站。 含有国内广告联盟的广告 R-18向（咱就不举例子了……） 只有满足下面的全部要求，咱才会和汝交换友链呐~ 汝本人热爱自由。 网站中大部分的元素能被现代浏览器（Firefox，Chrome，Microsoft Edge一类的）正常显示。 （仅限博客型网站）有及时更新的RSS 广告不要太多…… 加分项 大部分页面支持[[w:HTTPS|HTTPS]]访问（能有[[w:HSTS|HSTS]]更好） 汝的内容以像'''知识共享 署名-相同方式共享'''一类的自由文化协议授权。 活跃于开源社区 喜欢折腾新鲜技术，但至少对一种技术有恒心和毅力 写过开源的程序，或对其他开源项目贡献过代码/文档 比较萌 （ 这才是正义呐！） 但是如果遇到下面的情况，可以全部忽略 咱主动找到汝换友链…… ……未完待续（蛤？） 话说了那么多，如果想和咱交换友链的话…… 那还等啥，还不赶紧在下面发个评论或者去Github提个Issue~","tags":"pages","title":"交换友情链接"},{"url":"https://blog.yoitsu.moe/ghost_blog_archlinux.html","text":"先祝大家 情人节 ( 烧烤节 ) 快乐~ (2333 为了让旅伴发发牢骚,就装了一个 Ghost 博客系统咯~ 汝连啥是 Ghost 都不知道? Ghost是用JavaScript编写的博客平台，基于MIT许可证开放源代码。Ghost的设计主旨是简化个人网站发布以及网上出版的过程。 Ghost是一款个人博客系统，它是使用Node.js语言和MySQL数据库开发的，同时支持MySQL、MariaDB、SQLite和PostgreSQL。用户可以在支持Node.js的服务器上使用自己的博客。 — Wikipedia 上的 \"Ghost (博客平台)\" 条目 简单来说,Ghost 是一套博客平台,是一套博客平台,是一套博客平台! (重要的事情说三遍😂😂) 要安装 Ghost 需要啥? 因为 Ghost 是用 Node.js 写成的,所以要安装 Ghost , 汝需要先装上 Node.js 和 npm 呗~ 截至写这篇文章时,Arch Linux 官方源里 Node.js 的版本是 5.6.0 ,而 Ghost 的计划是只支持 Node.js 的 LTS ( 长期支援 ) 版本, 而 Node.js 的长期支援版本是 0.10x,0.12x和4.2 .所以嘛...... 这里(和咱在 AUR 的 ghost 软件包里)用到了一个环境变量 GHOST_NODE_VERSION_CHECK=false 来不让 ghost 来检查 node 的版本,在 Node.js 下一个 LTS 版本(6.x)出来前先凑合一下呗~ 于是先安装 nodejs 和 npm : sudo pacman -S nodejs npm 如果汝认为自己的博客会做的比较大,需要一个数据库系统的话,咱推荐 mariadb 呗~ 从 AUR 安装 Ghost 然后从 AUR 安装 ghost AUR (这个包是咱更新的,有问题尽管 pia 咱~). 如果汝有 yaourt 的话, yaourt -S ghost 这会把 ghost 安装在 /srv/ghost/ 目录,由于创建的 ghost 用户不能通过 shell 登录,要修改这个目录的文件的话: 修改 /etc/passwd 文件: ghost:x:738:738::/srv/ghost:/usr/bin/nologin 把 /usr/bin/nologin 换成 /bin/bash ,保存. 这样以后可以通过 sudo su ghost 切换到 ghost 用户对 /srv/ghost 目录写入了. 通过下面的命令以 ghost 用户运行一条命令: # su 后面的 -s 参数可以制定切换用户后运行的 shell , # -c 参数可以指定要运行的命令. sudo su ghost -s /bin/bash -c \"此处是汝的命令,记得带上引号\" 通过源代码安装 Ghost 首先把 ghost 的源代码下载下来并解开: # 这时最新的版本是0.7.6. wget https://ghost.org/zip/ghost-0.7.6.zip unzip ghost-0.7.6.zip cd ghost-0.7.6 接下来通过 npm 安装需要的依赖,因为上面的提示嘛~ GHOST_NODE_VERSION_CHECK = false npm install 修改配置文件 如果是通过 AUR 安装的,配置文件位于 /srv/ghost/config.js 如果是通过源代码安装的,从目录中先复制一份样例出来呗~ cp config.example.js config.js 这里的例子是修改 Production 一节 (这一节是汝的 Ghost 实际运行时的配置,下面的 Development 一节是开发时的配置) server: { host: '127.0.0.1', port: '2368' } }, 如果汝的 Ghost 和汝进行操作的电脑是同一个 通过下面的命令来测试汝的 Ghost 呗~ cd /path/to/ghost GHOST_NODE_VERSION_CHECK = false 如果汝是从 AUR 安装的,可以通过 Systemd 来启动 sudo systemctl start ghost 现在打开 http://localhost:2368 看看效果呗~ 如果汝的 Ghost 和汝进行操作的电脑不是同一个 比如汝在 VPS 上安装了 Ghost,就需要用一个 web服务器通过反向代理来访问呗~ 首先修改 config.js 把 Production 中的 URL 换成汝的网址啦~ 如果汝在用 Nginx, 把这一段增加到汝的 server 块中: location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://127.0.0.1:2368; # 汝的更多自定义设置 } 如果汝在用 Apache, 把下面一段添加到汝的 httpd.conf 的 vhost 段中(首先要启用 mod_proxy 模块~): ProxyPass / http://localhost:2368/ ProxyPassReverse / http://localhost:2368/ ProxyHTMLURLMap http://localhost:2368/ / RequestHeader set X-Forwarded-For $proxy_add_x_forwarded_for RequestHeader set Host $host RequestHeader set X-Forwarded-Proto $scheme 然后重新启动 ghost 和 web 服务器以后试试通过汝的网址访问? 打开 http://汝的ghost网址/ghost/ 开始设置汝的 Ghost 博客呗~ 参考资料 Ghost Blog 文档 Apache httpd mod_proxy 文档","tags":"Tech","title":"在 Arch Linux 上安装 Ghost 博客系统"},{"url":"https://blog.yoitsu.moe/aur_sumbiting_guidebook.html","text":"通过上一次的 「创建一个软件包」 , 汝应该已经创建了一个 (或是 N 个) 软件包了吧,如果汝想分享给其它人的话,上传到 AUR 其实是最方便的方法呗~ 前几天被 #archlinux-cn 的各位吐槽了中文和英文之间空格的问题,原谅咱写文章时太随性😂 再来回顾一下 Arch User Repository 的打包规范呗~ 不合规范的软件包可能会在不经过提醒的话直接删除. Arch Linux 打包标准 对于某些特定平台的软件包(例如 Web 应用)有不同的打包规范,记得看哦~ 提交软件包到 AUR 的规则 看了 Wiki 以后,是否觉得自己的软件包符合规范了? 如果确定的话,接着往下看呗~ 第一步:注册一个 AUR 帐号 去 https://aur.archlinux.org/register/ 注册一个帐号呗~ 第二步:为 AUR 准备一个 SSH 密钥 因为 AUR 现在用 Git 提交,所以没有一个 SSH 密钥是不行的呐~, 建议为 AUR 生成一个新的证书,这样一旦发现问题就可以直接吊销诶(不要把鸡蛋放在一个篮子里~) 可以用 ssh-keygen 命令生成新的密钥: $ ssh-keygen Generating public/private rsa key pair. # 为汝的公钥和私钥决定一个存放的位置呗~ Enter file in which to save the key ( /home/horo/.ssh/id_rsa ) : /home/horo/.ssh/example # 为私钥设置一个密码,可以省略,但是为了安全还是设置一个呐~ Enter passphrase ( empty for no passphrase ) : Enter same passphrase again: # 汝的私钥保存在汝决定的路径中 Your identification has been saved in /home/horo/.ssh/example. # 汝的公钥保存在汝决定的路径中,不过扩展名为.pub Your public key has been saved in /home/horo/.ssh/example.pub. # 这是汝的密钥指纹,用来区分不同的密钥 The key fingerprint is: SHA256:mwk7FvA2E0ycw+E8NYOr1+OL3+0qnF6PFMZ/Ndxuw84 horo@Yotisu The key ' s randomart image is: +--- [ RSA 2048 ] ----+ | oo++ | | = *. o | | . *o | | o.o . . . | | .B.S + oo | | ...*o = o .o. | | .+o+oo . .oo | | . o = + + .o.. | | .o+o+o+ E | +---- [ SHA256 ] -----+ 然后在 AUR Web 界面上点击 \"My Account (我的账户)\" ,把汝的公钥里的内容填进 \"SSH Public Key:\" 一节中,保存. 接下来编辑 ~/.ssh/config , 告诉ssh命令连接到 aur.archlinux.org 用汝新创建的密钥呗~ Host aur.archlinux.org IdentityFile ~/.ssh/example # 记得用汝自己的私钥路径 User foo # 记得换成汝自己的用户名. 第三步:提交软件包到 AUR 用下面的命令创建一个新的仓库: # 用汝希望的名称替换foobar. # 从不存在的仓库中克隆或推送，将会自动创建此仓库。 git clone ssh://aur@aur.archlinux.org/foobar.git 这时汝的当前目录下会多出一个以汝的软件包名命名的文件夹(例如 foobar ), 把汝的软件包需要的文件(PKGBUILD,有时还有些其他的文件)放到这个文件夹内. 接着记得写一个 .SRCINFO (供 AUR Web 界面解析的元数据), 可以通过 pkgbuild-introspection 包内的 mksrcinfo 工具生成. 每一次提交都要包含最新的 .SRCINFO 文件!不然服务器会 傲娇的 拒绝汝的提交呐~ 然后普通的使用 Git 来提交呗~ # 还是老话,不要照抄,按汝实际的状况来. git add . git commit -m \"Example\" git push 在 AUR 上搜索汝的软件包试试?(像这样 parsoid-git AUR ) 可能的后续工作 汝以为把软件包提交上就结束了? 一旦上游更新了,汝就要及时的更新诶(年久失修的包会被删除) 关注下方的评论,聆听用户的 建议 ( 抱怨 ) 并试着改进汝的软件包呗~ 发觉自己没有精力维护某个软件包?可以通过AURweb界面 disown 一个软件包或是在AUR邮件列表发条消息.","tags":"Tech","title":"AUR 纯萌新向入门教学(3)-提交软件包到AUR"},{"url":"https://blog.yoitsu.moe/aur_packaging_guidebook.html","text":"上一次咱说了 「从AUR中安装软件包」 ,其实如果汝足够 触 的话,不妨自己创建个软件包呗~ 首先为啥不读读ArchWiki咧? ArchWiki ,短小精悍,汝值得拥有呐~ 创建软件包 PKGBUILD Arch Linux 打包标准 如果因为各种原因看了Wiki还不明白的话,接着往下看呗~ 第一步:以普通的方式安装软件 看看 base-devel 装了没? sudo pacman -S base-devel --needed 从上游把软件的源代码下载下来,按照上游的文档编译和安装(典型的例子像这样): ./configure make make install 如果汝为了顺利安装做了任何的调整(比如改了些源码或者打上了补丁),记下来操作步骤,待会儿编写PKGBUILD时要用到哟~ 第二步:编写PKGBUILD文件 PKGBUILD是一个shell脚本,包含 Arch Linux 在构建软件包时需要的信息. Arch Linux 用 makepkg 创建软件包.当 makepkg 运行时,它会在当前目录寻找 PKGBUILD 文件,并依照其中的指令去获取依赖文件,编译出 pkgname.pkg.tar.xz 文件.生成的包内有二进制文件和安装指令,可以使用 pacman 进行安装. pkgname,pkgver,pkgrel和arch是必须包含的变量.license在构建包时并不强制要求,但若要分享 PKGBUILD文件,推荐加上该变量,否则 makepkg 会有警告. — ArchWiki:PKGBUILD 获得原型 ArchWiki上关于PKGBUILD的介绍已经很详细啦~,从 /usr/share/pacman/ 找个合适的原型复制下来: PKGBUILD.proto (经典原型😂) PKGBUILD-vcs.proto (如果汝的源码来自像SubVersion,Git,Mercurial一类的 SCCS ( 源代码控制系统 ) 的话,看下这份原型呗~) PKGBUILD-split.proto (如果汝要做一个分包的话) proto.install (希望在安装之前/之后运行一些别的命令?看看这份原型呗~) 阅读原型上的注释,然后删掉(随汝心意啦,但是如果汝想上传软件包的话,[Maintainer/偶尔会有的Contributor]是必须的😂) 起个名字 软件包的名字保存在pkgname里,只能用小写字母、数字和@ . _ + - 这些字符，且不允许用.或者-作开头。 别和 AUR 或官方仓库里面的软件包重名了哟~ 挑个许可协议 为了不造轮子,`传送门在此~ < https://wiki.archlinux.org/index.php/PKGBUILD_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87 )#license>`_ 编译和安装时的命令 makepkg的运行顺序大概像这样(从上到下): 获得,解压和检查源代码的散列值. pkgver():在汝的源代码来自各种SCCS时会有用,用来更新软件包的版本号. ArchWiki:VCS_package_guidelines 有一些范例,可以看看呗~ 不过记得得给 pkgver 变量随便赋个值先...... prepare():一些预处理源文件以进行构建的命令,比如打补丁...... 把汝为了让源代码顺利编译而运行的操作加到这里.不过首先要切换到源码目录呗~ 如果汝在编译前不需要干任何事情,这个函数可以不用. build():真正 撸起袖子 开始编译软件包的过程. 如果汝的软件包啥都不用编译,这个函数可以不用. 对于普通的configure-make-make install三部曲来说,build()可以写成这样(汝来决定那些注释的去留呗~) # 切换到源码目录 cd \" $ srcdir/ $ pkgname- $ pkgver\" # configure 和 make ,按照Arch Linux的规范,软件包都装在/usr目录 # 汝也许要按照上游的指示添加别的参数呐~ ./configure --prefix = /usr make 不要在这个函数中让用户进行交互,见 某个bug报告 check():用来执行make check和其他一些例行测试的地方,有时需要. package():把生成的文件打包成软件包的函数, 只有这个函数是必须的. pkg目录复制了根目录下软件安装路径的继承关系. 如果汝需要手动把文件放到根目录下,那么在这里你需要把文件放在pkg下相同的文件层级结构中诶~. 比如,把一个文件安装到/usr/bin,那么在伪root环境中对应的路径为$pkgdir/usr/bin. 对于普通的configure-make-make install三部曲来说,package()可以写成这样: make DESTDIR = \" $ pkgdir/\" install 在一些很罕见的情况下,软件只有安装在单一目录下时才能运行.在这种情况下汝还是老老实实把它安装到$pkgdir/opt下吧. 通常,软件在安装过程中会在pkg目录下先创建一系列子目录.如果没有的话,makepkg会报错,记得先在build()函数中提前手动创建这些目录哟. 同build(),不要在这个函数中让用户进行交互. 安装前后有事要做? 如果汝要在安装/升级/卸载前后运行其它命令,可以写个.install文件: pre_install - 安装前运行的脚本,可以传递版本号为参数. post_install - 安装后运行的脚本,可以传递版本号为参数. pre_upgrade - 升级前运行的脚本,可以按新版本号,旧版本号的顺序传递参数. post_upgrade - 升级后运行的脚本,可以按新版本号,旧版本号的顺序传递参数. pre_remove - 卸载前运行的脚本,可以传递版本号为参数. post_remove - 卸载后运行的脚本,可以传递版本号为参数. 这些函数运行的也是Bash脚本哦~ 然后在PKGBUILD中把 install 变量指向汝的 .install 文件的位置呗~ # 一般来说,.install的文件名应该和软件包名一致. install = 'foo.install' 需要用到配置文件? 如果汝的软件包要有些用户编写的配置文件,记得添加到backups变量里. 例如如果汝的配置文件是 /etc/foo : backup =( etc/foo ) 记得是相对于 / 的路径. 这样pacman就会在软件包升级时提醒用户合并新的和旧的文件,在卸载软件包时这些文件会被保留(除非用了 pacman -Rn ) 依赖,依赖,依赖! 重要的事情说三遍-- 架构相关的变量可以通过下划线加架构的方式指定：depends_x86_64=(), optdepends_x86_64=(). 依赖相关的变量有这些: depends: 真 运行时依赖 运行时 必须 的软件包列表,可以使用比较运算符来描述版本限制,如：depends=('foobar>=1.8.0'). 不过如果A依赖B,B又依赖C的话,A的depend里不用加上C😂😂 optdepends:运行时的可选依赖 一组不影响软件主要功能,但能提供额外特性的软件包.应该简要说明每个包所能提供的额外功能.有些可选依赖如果不安装,软件包的个别程序可能无法正常使用. optdepends可以这样写: optdepends =( 'foo: some description' ) 尽可能给每个可选依赖一个简洁的描述来方便用户决定装不装~ makedepends:只在编译时需要的依赖 仅在软件编译时需要的软件包列表.可以像depends序列里提到的一样指定最小版本依赖. 不过不要包含 base-devel 组的软件包! (要运行makepkg的话这个软件包组应该已经装上了) checkdepends:只在测试时需要的依赖 运行测试组件时需要,而运行时不需要的包列表.和makedepends一样,不要包含 base-devel 组的软件包. 只有编写了check()时再填这个变量哟~ makedepends和checkdepends中的软件包会因为makepkg的 -r 选项而在安装完成后删除. 散列值:安全第一 记得加上文件的散列值,makepkg会在编译前检查文件的散列值(和PKGBUILD中的散列值比较),一定程度上确保源代码不会篡改. 写法大概像这样: { 这里是汝选择的散列算法 }=( '{散列值}' ) 散列值的顺序取决于汝的sources变量,例如如果汝选择sha512sum的话: sha512sums =( \".....\" ) 建议使用sha256sums(或更高的位数),md5已经发现有 碰撞漏洞 ,sha1已经发现Preimage漏洞(已知校验和的情况下，可以生成一段字符串产生相同的校验和,) 如果汝的源代码来自SCCS的话,因为文件在不断变化,所以需要让makepkg跳过散列值检查: sha512sums =( \"SKIP\" ) 记得在修改某个文件以后用新的散列值这个变量呗~ 测试,测试,再测试 如果只是汝自己用的话，就不必做这个质量保证了，因为只有汝一个人需要忍受这些错误呗~. 运行下makepkg命令来确保没有问题。如果PKGBUILD没有错误，将会生成一个包，但是如果PKGBUILD被破坏或未完成，它会抛出一个错误。 如果运行makepkg 成功，会生成一个名为$pkgname-$pkgver.pkg.tar.gz的新文件。 这个文件可以使用pacman -U 安装一下试试呗~,不过，一个包被构建并不代表你的工作就完成了！ 只有当所有文件的结构都正确才能确保完成，例如前缀不对就不行。 可以使用pacman的查询功能显示软件包包含的文件及依赖的文件，然后将它于你认为正确的对比。\"pacman -Qlp <package file>\" 和\"pacman -Qip <package file>\" 可以完成这项工作。 如果包看起来是正确的，那汝的工作就完成了。但是如果汝打算发布这个包或PKGBUILD，还是需要确认确认再确认包的依赖关系。 同样要确保安装的软件确实很完美的运行！就算汝释放了一个包括所有必需文件的包，但是由于一些配置选项使它不能很好的工作，这真是让人恼火。 可以用namcap帮助检查软件包的依赖是否正确: # 检查PKGBUILD文件 $ namcap PKGBUILD # 检查某个软件包 $ namcap <package file name>.pkg.tar.xz Namcap会帮汝干这些事: 检查PKGBUILD文件里的一些常见错误 用ldd扫描包中所有的ELF文件，自动报告缺失或可去除的依赖。 启发式搜寻缺失或冗余的依赖。 理想的情况是没有输出(真的么?),如果遇到了错误,去ArchWiki上查找对应的解决方案呗~: https://wiki.archlinux.org/index.php/Namcap 生成源码包 用下面的命令生成一个源码包: makepkg --source 这会在当前目录生成一个 .src.tar.gz 文件,汝可以在上传到AUR前先分享给其他人帮汝检查一下呗~ 到这里汝应该完成了一个软件包了呗~,下次咱会告诉汝怎么把汝创建的软件包提交到AUR上呗~","tags":"Tech","title":"AUR 纯萌新向入门教学(2)-创建一个软件包"},{"url":"https://blog.yoitsu.moe/aur_fresh_guidebook.html","text":"没玩过AUR好意思说自己是Arch Linux用户？ 尽管Arch Linux官方软件仓库里的软件包够多了,连MediaWiki或者OwnCloud一类的用 最好的编程语言 PHP写的应用都有对应的软件包啦~( TU:反正闲着也没事干,打个包呗~ ), 但是汝是不是有时试图pacman的时候: error: target not found: { 此处用汝希望安装的软件包名称替换呗~ } 这时咋办咧?就该AUR上场了呗~ 什么是AUR(Arch User Repository,Arch 用户软件仓库)? Arch用户软件仓库（Arch User Repository，AUR）是为用户而建、由用户主导的Arch软件仓库。AUR中的软件包以软件包生成脚本（PKGBUILD）的形式提供，用户自己通过makepkg生成包，再由pacman安装。创建AUR的初衷是方便用户维护和分享新软件包，并由官方定期从中挑选软件包进入community仓库。 许多官方仓库软件包都来自AUR。通过AUR，大家相互分享新的软件包生成脚本（PKGBUILD和其他相关文件）。用户还可以为软件包投票。如果一个软件包投票足够多、没有协议问题、打包质量好，那么它就很有希望被收录进官方[community]仓库（以后就可以直接通过pacman 或 abs 安装了）。 — ArchWiki:Arch User Repository 安装AUR里的软件包前要做好哪些准备咧? 其实只有一项,安装 base-devel 软件包组,内含编译软件包所需要的工具. sudo pacman -S base-devel 对于汝个人而言,需要 会使用 终端和 看得懂bash脚本 (因为PKGBUILD其实就是bash脚本啦~,为了安全起见建议在安装时检查PKGBUILD呗~) 下面是一句没啥用处的警告: AUR packages are user produced content. Any use of the provided files is at your own risk. AUR中的软件包是由用户上传的,使用即表示汝愿意风险自担呗~ 第一步:寻找和获得软件包的PKGBUILD文件 这里是AUR的网址呗~: https://aur.archlinux.org/ 打开后大概像这样: 可以在另一侧的\"English\"那里的下拉菜单里将AUR web 界面的语言修改成中文呗~ 建议先 注册一个账户 , 这样便可以使用更多功能呗~ 然后在搜索框里输入需要的软件包的名称就可以搜索呗~ 点击对应软件包的名称就可以进入软件包的详细信息呗~ 点击右侧的\"Download snapshot\"就可以下载到软件包的快照.(比如pypi-pip.tar.gz) 一般包含PKGBUILD,有些软件包中可能包含其它文件(例如Systemd 单元啥的) 可以用tar来解开它呗~ # 如果汝不知道tar 怎么用的话,man一下呗~ (man tar) tar xzf pypi-pip.tar.gz 安装软件包 首先切换到软件包的目录，然后检查一下PKGBUILD： 务必认真检查所有文件！ PKGBUILD和所有.install文件都是shell脚本文件，包含若干函数，由makepkg调用并执行。 这些函数可以调用任何命令，可能包含恶意或危险代码。 makepkg将通过fakeroot（意为\"假root\"）执行这些命令，能在一定程度防止恶意代码损坏系统，但还是小心为好。 如有疑问，可以到论坛或邮件列表询问。 在 仔细 ( 几乎没有 ) 检查完所有文件以后,运行makepkg来创建并安装软件包呗~ # 下面的三个选项分别是 # (i) 在编译完成后安装, # (s) 安装编译时需要的依赖关系, # (r) 在安装完成后删除只在编译时需要的软件包 # 关于makepkg的更多帮助,可以查看手册页(man makepkg) # 或者在ArchWiki上查阅呗~ makepkg -rsi 不过经常会出现这样的状况: == > 正在创建软件包：pypy-pip 8.0.2-1 ( 2016年 01月 30日 星期六 15:18:38 CST ) == > 正在检查运行时依赖关系... == > 正在检查编译时依赖关系 == > 正在安装缺少的依赖关系... 错误：未找到目标：pypy-setuptools 错误：未找到目标：pypy3-setuptools == > 错误： 'pacman' 无法安装缺少的依赖关系。 这表示这个软件包依赖的某些包也在AUR里,汝只好先把它们装上呗~,或者用个AUR Helper(一会儿咱会介绍一个AUR Helper) 在安装完需要的依赖以后再运行下makepkg,大概像这样~: == > 正在创建软件包：pypy-pip 8.0.2-1 ( 2016年 01月 30日 星期六 15:27:02 CST ) == > 正在检查运行时依赖关系... == > 正在检查编译时依赖关系 == > 获取源代码...... -> 正在下载 pip-8.0.2.tar.gz... == > 正在验证源代码文件 sha256sums... pip-8.0.2.tar.gz ... 通过 == > 正在释放源码...... -> 正在解压缩 pip-8.0.2.tar.gz，使用 bsdtar == > 正在进入 fakeroot 环境... == > 正在开始 package_pypy-pip () ... # 省掉编译的过程..... == > 正在清理安装... -> 正在清除不打算要的文件... -> 正在删除 libtool 文件... -> 正在移除静态库文件…… -> 正在压缩 man 及 info 文档... -> 正在从二进制文件和库中清除不需要的系统符号... == > 正在创建软件包 \"pypy-pip\" ...... -> 正在生成 .PKGINFO 文件... -> 正在生成 .MTREE 文件...... -> 正在压缩软件包... == > 正在离开 fakeroot 环境。 == > 完成创建：pypy-pip 8.0.2-1 ( 2016年 01月 30日 星期六 15:27:40 CST ) == > 正在安装 pypy-pip 软件包组，使用 pacman -U... 如果汝有sudo的能力的话,接下来输入密码,然后像原来一样安装软件包呗~ 是不是感觉自己处理依赖关系和一遍遍的makepkg已经让汝开始挠头了么,接着往下看. 使用AUR helper简化安装过程 Arch官方永远不会提供安装AUR（和其他不受支持）软件包的便利工具， AUR用户应当对软件编译有一定了解。 然而官方不做并不代表没有😂😂,有一个叫做yaourt的工具在Archer间口口相传.yaourt就是一个AUR helper. yaourt on AUR 先用上面的方法安装好yaourt,然后像用pacman一样运行yaourt就好(除了不要以root用户运行) yaourt -S foo yaourt会帮汝下载PKGBUILD,安装需要的依赖,运行makepkg等一系列操作哟~ 2月1号Pacman更新到了5.0，和yaourt的兼容性还不明确…… 登录到AUR以后可以进行的操作 登录到AUR以后,软件包描述页面右侧的\"软件包操作\"的若干命令就可以使用了: 将这个包标记为过期 如果汝发现上游更新了而AUR没更新的话,可以通过这样提醒维护者更新,长时间无人维护的软件包可能被删除. 为这个软件包投票 觉得Ta好就给投一票呗~,票数多而且符合 Arch Linux 软件包规范 的软件包可能会被TU收录到官方软件仓库诶~ 当有新评论的时候提醒我 评论可以用来回报软件包的问题或是改进建议等等,如果这个选项启用的话,当评论更新时汝就会收到通知呗~ 提交请求 可以提交像是合并,更名或是移除软件包的请求. 诶好像有些长了呐~,所以下一次咱再说如何创建软件包并提交到AUR上呗~","tags":"Tech","title":"AUR 纯萌新向入门教学(1)-从AUR安装软件包"},{"url":"https://blog.yoitsu.moe/archlinux_cn_community_unoffical_newbie_guide.html","text":"汝要入坑Arch Linux了吗?那还不赶紧加入Arch Linux中文社区~ 什么是Arch Linux? Arch Linux 是一个针对 i686/x86-64 平台独立开发的 GNU/Linux 发行版，遵循轻量、简洁、优雅的开发原则，借灵活的架构应用于各种环境。Arch 安装后只提供最基本的系统，用户可以根据自己的需求来搭建不同的系统环境。官方并不提供图形化的配置工具，多数系统配置是通过修改文本文件来进行的。Arch 尽力提供最新稳定版本的软件。 Arch Linux 使用 Pacman 作为包管理器，它在提供了一个简单的包管理器同时，也提供了一个易用的包构建系统，使用户能够轻松地管理和定制官方提供的、用户自己制作的、甚至是来自第三方的各种软件包。仓库系统也能够让用户轻松的构建和维护自己的编译脚本、软件包和仓库，这样将有助于社区的成长和建设。 Arch Linux 的基本安装包由 [core] 软件库提供。此外 [extra], [community] 和 [testing] 软件库则提供了大量的的高品质软件以满足你的需求。Arch Linux 同时也通过 Arch 用户软件仓库(AUR)提供了 [unsupported] 软件库，里面有大量的编译脚本，用户可以通过 makepkg 工具轻松地从源码中编译软件。 Arch Linux 采用\"滚动升级\"策略，这样可以实现\"一次安装，永久更新\"。升级到下一个\"版本\"的 Arch Linux 几乎不需要重新安装系统，只需一行命令，你就能轻松的享受到最新的 Arch Linux。 Arch Linux 努力和上游软件源码保持一致，只有使程序能够在 Arch Linux 正常编译运行的补丁才会被加入更新中。 总之， Arch Linux 是一个灵活、简洁的、满足有一定经验的 Linux® 用户的需求的发行版。它强大且易于管理的特性，使其成为可以完美胜任服务器和工作站的发行版。它可以变成任何你想要的样子。如果你也认为这是一个 GNU/Linux 发行版该做的，欢迎你来自由使用并参与其中，为社区做出贡献，欢迎来到 Arch Linux！ — Arch Linux 中文社区 ,翻译自 Archlinux.org . 先把Arch Linux装上先~ ArchWiki的文档应该算比较详细的啦~ 第一次安装Arch Linux的新手建议看看 Beginners' guide 有经验的用户可以看看 Installation guide 想找交互式的安装程序? 可以试试 ArchBoot 加入Arch Linux中文社区论坛呗~ 用Arch Linux时发现了些问题?英文水平不足担心发到 官方论坛 泥牛入海? 来中文论坛呗~ 中文论坛在这~: https://bbs.archlinuxcn.org/ 和参加其他的论坛讨论一样,先读读 phoenixlzx 写的 Arch Linux 中文社区 新手生存指南 , 官方编写的论坛礼仪指南 也可以作为参考呗~ 加入中文社区的聊天频道呗~ 和论坛相比,中文社区聊天频道更 活跃 ( 洪水 ) 呗~ 在多才多艺的百合仙子 lilydjwg , Tox传教士 quininer ,和 PhD farseerfc 的协力下,社区交流群实现了irc+Telegram+xmpp+Tox的多通道联通,撒花~ 加入irc频道 Web界面在这: #archlinux-cn 如果汝使用irc客户端的话: irc服务器: irc.freenode.net 端口: 7000 (SSL) / 6667 (Plain) 通过XMPP加入 使用XMPP帐号添加 talk@archlinuxcn.org 为好友即可加入。成功加入将收到欢迎信息。 通过Tox加入 添加下面那个Tox ID为好友,然后按照它的提示操作呗~ 34922396155AA49CE6845A2FE34A73208F6FCD 6190D981B1DBBC816326F26C6CDF3581F697E7 通过Telegram加入 hmmm.....为保护群组不被外星人攻击，所以这里就不贴上链接啦~ 汝可以通过其它方法加入,贴上汝在Telegram的用户名呗~(其它已经在群里的用户会帮汝拉进来......) 或者,在Telegram上添加@Jqs7Bot这个机器人,通过群组查询中的Linux分类找到#archlinux-cn(irc)的链接再加入呗~ 群内的一般原则 要优雅,不要污~ (irc/xmpp/tox) 推荐一个由百合仙子帮忙的图床 https://img.vim-cn.com/ 呗~ (Telegram) 发没压缩的图片和声音的话irc可是收不到的哟~ 如果汝的英语水平也不错的话...... 如果汝的英语水平不错的话，太棒啦~,社区正需要汝这样的人呐~ 汝可以...... 帮助翻译ArchWiki,可以在 ArchWiki上翻到相应页面呗~ 创建软件包并提交到 AUR(Arch Linux User Repository) ,高质量的软件包可能会被TU(授信用户)收录到官方软件仓库呗~ 参与开发 , 然后成为下一个像felixonmars一样的领袖😂😂😂","tags":"Life","title":"Arch Linux 中文社区非官方生存手册"},{"url":"https://blog.yoitsu.moe/tox_trainee_guide.html","text":"Tox,一种新型的聊天协议.如果汝关注安全和隐私,不妨来看看呗~ 再说一遍Tox是啥? Tox是一种新型的通讯协议,它的目标是——提供一个无法监控的 Skype 替代品——彻底的加密，没有后门，无需中间服务器。 由于Tox就是一个协议框架,不同的开发者开发了不同的软件呗~ Tox 官方维护的wiki上可以找到不同平台可用的客户端列表呐 在下面的例子中咱会先拿 qtox 来示范一下,汝可以从上面的列表中选择一个适合自己的客户端呗~ 首先按照上游的指南装好客户端呗~ 新建一个Tox个人资料 运行qtox,会弹出这样的窗口: 因为咱已经有一个Tox Profile所以是这样啦,汝直接按\"New Profile\"就好: 在Username那挑个用户名,Password那输入个密码呗~ 如果用SSH远程访问做类比的话,汝的Profile就是私钥,密码就是私钥的保护口令呗~ 汝输入的密码非常重要! 1.挑一个好的密码,如果不怀好意的骇客同时得到了汝的密码和profile,就可以冒充汝发送消息了诶. 2,记住汝的密码!虽然安全性很重要,但是一旦汝忘了密码,基本上就无法恢复了呗~ 确认完毕之后就会进入到qtox的主画面了呗~(旁边一圈是咱加上的注释,原谅咱不怎么会用GIMP......) 修改个人资料 点击头像的区域就可以修改自己的个人资料了呗~ 就像界面介绍的那样,Name和Status是公开的信息,所以仔细考虑一下选择一个合适的呗~ 不过问题来啦,木有好友咧? 添加好友 要添加好友的话,先让汝的好友把Ta的Tox ID用其他的手段让汝知道呗~ E1F1C7DEA73D8126A1DEE9EAE5B45E21FB17E75F2319B7823A346B8C427EB272C80A89B69B4E —Tox ID 是像这样的十六进制数呗~ 然后到添加好友的界面把Tox ID输入进去.必要的话,附上一段消息让Ta知道汝是谁呗~ 一开始时汝的好友列表只会显示对方的Tox ID呐,像这样: 当Ta同意汝的好友请求以后,汝的好友列表上就会显示Ta的Name和Status呗~ 然后像平常一样聊天呗~ 要想让其他人和汝成为好友的话,把汝自己的Tox ID告诉Ta,让Ta像这样添加汝为好友呗~ 发起群聊 Tox也是可以发起群聊的哟~首先创建一个(qtox里点击下方\"创建群聊\"按钮就可以了诶~) 汝也可以邀请好友加入群聊呗~(qtox中右键点击某个好友-邀请加入群聊-汝的群聊名称呗~) 只不过万一汝退出了tox,下次登录时是不会加入上次加入的群聊的,汝只好让好友再邀请汝一次呗~ 导出Tox的配置文件 必要时可以导出汝的配置文件,这样就可以在其他地方连接到汝的Tox用户了呗~ qtox的话,可以在Profiles页面通过\"导出\"选项导出汝的配置文件呗~ 最后 这些就是tox基本的用法啦~,对于其他的客户端的话,不妨去阅读对应的文档呗~ 如果汝有意帮助开发Tox的话, 来这看看呗~ 哦,差点忘记啦,这是咱的Tox ID,大家可以试试看呗~ 7BC803F7F9B8A7230EE181AB45CA909DE446D36A7BC3A275D5576439E0CF7546FF4E2C4665CC","tags":"Tech","title":"Tox新手入门"},{"url":"https://blog.yoitsu.moe/new_yoitsu_birth_notes.html","text":"说好的下一期来啦~,新的\"约伊兹的萌狼乡手札\"是怎么样诞生呐~马上就告诉汝呗~ 安装Pelican然后进行初始设置 在咱写这篇文章时, farsserfc 已经把Pelican打好包放进Arch Linux 官方软件仓库啦好棒~ Arch Linux用户可以这样安装: sudo pacman -S pelican 其它操作系统可以通过pip安装: sudo pip install pelican 接着运行设置程序建立一个工作文件夹: pelican-quickstart 接着开始挖坑呗~,用 reStructuredText 或 Markdown 开始写文章然后放到 contents 文件夹里,像这样: (reStructuredText) 这里是标题 =========================================== :lang: 这里填语言 :date: 写文章的日期 :Category: 分类 这里是内容 (Markdown) Title: 这里是标题 date: 写文章的日期 Category: 分类 这里是内容 然后运行一个命令来测试 make html # 生成html make serve # 在127.0.0.1:8000 运行一个测试服务器. 然后打开浏览器输入 localhost:8000 ，你就能看到一个初生的很 简洁 ( 难看 ) 的博客了，不过不要担心，它是只丑小鸭，很快就会像天鹅般美丽(真的么?)。 修改 ( 调教 ) Pelican的主题 可能是一时抽风没找到合适的Material Design风格的框架， 于是走上了Metro UI CSS的不归路...... Metro UI CSS的项目主页在这里 http://metroui.org.ua 咱拿了pelican内置的simple主题做起步,把Metro UI CSS文件夹里的 /css 和 /js 复制到主题的 /statics 文件夹里. 现在的文件夹结构大概像这样: . ├── cache 生成頁面的 pickle 緩存 ├── content 讀取的全部內容 │ ├── <categories> 按分類存放的文章 │ ├── pages 像 About 這樣的固定頁面 │ └── static 文章內用到的靜態內容 ├── drafts 文章的草稿箱 ├── Makefile 生成用的 makefile ├── pelicanconf.py 測試時用的快速 Pelican 配置 ├── publishconf.py 部署時用的耗時 Pelican 配置 ├── output -> ../kenookamihoro.github.io ├── plugins -> ../plugins └── theme -> ../yoitsu 然后这个内容 repo 中的三个符号链接分别指向三个子 repo（为啥没用 git submodule ? 因为咱技术不精还不会用......）。 theme 指向 yoitsu ，是咱修改过的 pelican 主题啦。 plugins 指向 pelican-plugins 最后 output 指向 kenookamihoro.github.io 也就是发布的静态网站啦。 而主题文件夹的结构大概像这样： . ├── static 主题中用到的静态文件，例如js和css ├── templates 供jinja使用的模板页面 │ ├── archives.html 文章归档 │ ├── article.html 每个文章 │ ├── author.html 作者 │ ├── base.html 所有模板的基础 │ ├── category.html 分类 │ ├── index.html 首页 │ ├── page.html 每个页面 │ ├── pageination.html 分页 │ ├── search.html 搜索 │ └── tag.html 标签 └── 然后记得修改pelican.conf告诉Pelican那些页面是模板那些页面是直接生成的呐~ # DIRECT_TEMPLATES 告诉Pelican哪些页面是直接用来生成特定页面的...... DIRECT_TEMPLATES = (( 'index' , 'archives' , 'search' )) 接下来开始调教主题呗~,直接给出官方的教程呗~ Pelican doc:Creating Themes 经过一番 仔细 ( 无脑 ) 调教以后,就成了汝等现在看到的样子了呐~ PS:咱自己做的这套主题还木有到能拿来复用的程度(原因主要是咱有很多是直接写死在主题里的设置),所以这又是一个坑呗~ 装插件 作为一套博客系统,Pelican自然有很多的插件可以安装呐~,不信的话去看看`pelican-plugins里有多少插件呗~ < https://github.com/getpelican/pelican-plugins >`_ 咱启用的插件有这些: PLUGINS = [ \"better_codeblock_line_numbering\" , 'tipue_search' , 'neighbors' , 'series' , \"render_math\" , 'extract_toc' , 'tag_cloud' , 'sitemap' , 'summary' , 'bootstrapify' , 'twitter_bootstrap_rst_directives' ] 具体的设置流程嘛,请允许咱引用一下 farseerfc.me:重新設計了 Pelican 的主題與插件 呗~ 实现动态格言 动态格言的实现来自 fiveyellowmice 啦~(咱不是JavaScript专家呐~,就不谈具体的实现了呗~) 首先是一段修改某一个元素的类的JavaScript(当然还需要 velocity ): < script src = \"/theme/js/velocity.min.js\" ></ script > < script > document . addEventListener ( \"DOMContentLoaded\" , function () { $ ( \".menu-button\" ). on ( \"touchstart\" , function () { $ ( \".menu-wrapper\" ). removeClass ( \"trigger\" ); if ( $ ( \".nav-items\" ). is ( \":visible\" ) ) { $ ( \".nav-items\" ). velocity ( \"finish\" ) . velocity ( \"slideUp\" , { delay : 200 , duration : 400 , easing : \"easeInQuad\" }) . velocity ( \"fadeOut\" , { delay : 200 , duration : 400 , easing : \"easeInQuad\" , queue : false }); } else { $ ( \".nav-items\" ). velocity ( \"finish\" ) . velocity ( \"slideDown\" , { delay : 200 , duration : 400 , easing : \"easeOutQuad\" }) . velocity ( \"fadeIn\" , { delay : 200 , duration : 400 , easing : \"easeOutQuad\" , queue : false }); } }); }); </ script > 然后新建一个 Github gist 填上动态格言,像这样(大括号里的内容可以添加多个): [ { \"content\" : \"example\" , \"author\" : \"someone\" }, ] 再写个JavaScript来从JSON中提取格言然后填到html里: < script > document . addEventListener ( \"DOMContentLoaded\" , function () { $ ( \".site-description\" ). after ( $ ( \"<blockquote>\" ). attr ( \"id\" , \"fortune\" ). css ( \"display\" , \"none\" )); $ ( \".site-description\" ). after ( $ ( \"<blockquote>\" ). attr ( \"id\" , \"fortune\" ). css ( \"line-height\" , \"1.4rem\" )); $ . getJSON ( \"https://api.github.com/gists/07ca2edea6e507bf40f5\" , function ( data ) { fortunes = JSON . parse ( data . files [ \"quotes.json\" ]. content ); randomFortune = fortunes [ Math . floor ( Math . random () * fortunes . length ) ]; if ( randomFortune . author === undefined ) { $ ( \"#fortune\" ). html ( \"<p>\" + randomFortune . content + \"</p>\" ); } else { $ ( \"#fortune\" ). html ( \"<p>\" + randomFortune . content + \"</p>\" + \"<small>\" + randomFortune . author + \"</small>\" ); } $ ( \"#fortune\" ). velocity ( \"slideDown\" , { duration : 400 , easing : \"easeOutQuad\" }); }); }); </ script > 最后的效果汝也应该看到了呗~ 发布 通过几条命令可以发布~ make publish 然后用git提交到Github就好...... 好吧这就是咱的全过程啦(雾)","tags":"Tech","title":"新约伊兹的萌狼乡手札诞生全过程伪实录"},{"url":"https://blog.yoitsu.moe/visualeditor_for_mediawiki.html","text":"为MediaWiki安装来自 维基媒体基金会 的 可视化编辑器 . 连维基百科都要Hold不住啦~ 许多新用户不会着手大幅度修改，而只是做些细节调整，不过仅仅阅读源代码就必须学标记语言了。当我们的用户在演示操作时，这把他们吓走了。 早在 2004 年，社群开始一再认识到必须采用更好的编辑方式。因为人们的请求，更重要的是他们的需要，所以我们开发了可视化编辑器。 Wiki 标记语言让新人害怕，这种程度会随着其他站点的迁离而加剧。如果我们不开发可视化编辑器，那么图表的走势会在接下来五年中变得更加糟糕。 — MediaWiki.org 所以他们才 痛定思痛 决定开发可视化编辑器么😂 开始之前-检查一下要求 可视化编辑器(下面就说VisualEditor呗~)还需要一个叫 Parsoid 的程序来承担把wiki标记转化成html的任务啦(看下图)~,所以需要服务器来运行它呐~ 安装Parsoid(Ubuntu 14+ / Debian 7+ ) 上游的指南在这(好好学英语呗~) https://www.mediawiki.org/wiki/Parsoid/Setup Ubuntu和Debian系统的话直接添加MediaWiki.org的软件源然后通过apt安装就好了啦~ 首先添加MediaWiki.org的GPG公钥: sudo apt-key advanced --keyserver keys.gnupg.net --recv-keys 664C383A3566A3481B942F007A322AC6E84AFDD2 然后添加Parsoid源: sudo echo \"deb https://releases.wikimedia.org/debian jessie-mediawiki main\" > /etc/apt/sources.list.d/parsoid.list 安装需要的软件包: sudo apt-get update && sudo apt-get install curl parsoid 然后看下下面一节的内容修改一下配置文件呗~ 其它系统?手动安装呗~ 上游的指南在这(还是要好好学英语呗~) https://www.mediawiki.org/wiki/Parsoid/Developer_Setup 首先汝要装上Nodejs(>0.8,建议0.10或更新的版本呐~),还有git. 具体的安装方法为了避免降低正交性 (其实是系统太多不好写......) ,就麻烦汝自己去找了呐~ 「呵。咱是贤狼，不是神呐。如果汝开始会期待起咱能够泄露天机给汝，那咱就得从汝眼前消失了呗。」 node --version # 如果是Debian或Ubuntu ,输入 nodejs --version 然后用git克隆版本库呗~ git clone https://gerrit.wikimedia.org/r/p/mediawiki/services/parsoid 用npm安装上相应的依赖: npm install 然后看下面一节的内容修改一下配置文件呗~ 修改配置文件 如果是通过软件源安装的,配置文件位于 /etc/mediawiki/parsoid/settings.js 如果是通过git下载的,从parsoid目录中先复制一份样例出来呗~ cp localsettings.js.example localsettings.js 打开配置文件,找到这一段内容,然后改它~: parsoidConfig . setMwApi ({ // The \"prefix\" is the name given to this wiki configuration in the // (deprecated) Parsoid v1 API. prefix : 'localhost' , // optional // The \"domain\" is used for communication with Visual Editor // and RESTBase. It defaults to the hostname portion of // the `uri` property below, but you can manually set it // to an arbitrary string. domain : 'localhost' , // optional // This is the only required parameter: // the URL of you MediaWiki API endpoint. uri : 'http://localhost/w/api.php' }); 其中\"uri\"对应汝的wiki的api.php的位置,\"domain\"是汝的域名啦~.\"prefix\"可以自己起一个(反正因为换了API也没用啦~,不过测试时可能用得到) 启动服务 从软件源安装的? sudo systemctl start parsoid # Debian Jessie ,用Systemd启动 sudo service parsoid start # Debian Wheezy 或Ubuntu ,用init.d脚本启动. 如果汝不是通过远程访问执行的命令,可以在浏览器上打开 http://localhost:8142 来进行测试.试着加载 http://localhost:8142/汝设置的前缀/汝的wiki上的一个页面 试试呗~ 用git安装的? npm start 或者: node bin/server.js 可以用screen一类的工具让Parsoid在后台运行~ 如果汝不是通过远程访问执行的命令,可以在浏览器上打开 http://localhost:8000 来进行测试.试着加载 http://localhost:8000/汝设置的前缀/汝的wiki上的一个页面 试试呗~ 修改监听地址便于远程测试 改这一段: // Allow override of port/interface: //parsoidConfig.serverPort = 8142; //parsoidConfig.serverInterface = '127.0.0.1'; 反注释最后一行并改成0.0.0.0,就可以通过 http://服务器的IP地址:8142 访问啦~ 安装VisualEditor扩展 上游的指南在这: https://www.mediawiki.org/wiki/Extension:VisualEditor 首先从 这里 获得扩展然后上传到汝的wiki上的extensions目录呗~ 然后修改汝的LocalSettings.php: require_once \"$IP/extensions/VisualEditor/VisualEditor.php\"; // 反注释下一行来默认启用可视化编辑器 #$wgDefaultUserOptions['visualeditor-enable'] = 1; // 反注释下一行来启用测试中的功能 #$wgDefaultUserOptions['visualeditor-enable-experimental'] = 1; //在除了主名字空间以外的名字空间中也启用可视化编辑器(下面的例子是用户名字空间) $wgVisualEditorNamespaces=array_merge($wgContentNamespaces,array( NS_USER )); 完整的设置选项可以在扩展页面上找到. 然后在汝的wiki上试试看呗~","tags":"Tech","title":"为MediaWiki安装可视化编辑器"},{"url":"https://blog.yoitsu.moe/new_yoitsu_birth.html","text":"就像标题描述的一样，新的\"约伊兹的萌狼乡手札\"以Pelican之姿再次出发啦~ 为啥要重做？ 原来的 约伊兹的萌狼乡手札 是基于MediaWiki搭建的,但是MediaWiki的本来用途并不是来做博客的呐~,不过咱还是一直拖着......直到 Arch Linux 宣布PHP7进入官方软件仓库 ,咱升级以后两个关键的RSS扩展都坏掉啦~(应该都知道RSS对于博客型网站的重要性呗~),于是咱痛定思痛决定升级😂 为啥是Pelican? 主要的原因是 人生赢家 farseerfc 用的也是Pelican，这样咱可以照着他的经历少走一些弯路...... 为啥不用Hexo,Ghost一类的博客系统呢?因为咱不太会设置Node.js(想当初给MediaWiki装可视化编辑器就折腾了半天)😂😂😂 那么有哪些问题咧? 首先Pelican用的标记语言是rst(重组的文本)或是MarkDown,不过看情况Markdown是刚加入进来的,处理的还不够好,就先用rst呗~ 然而咱并不会rst的语法......只好找来个 语法指南 先照着看...... 关于旧站的打算? 介于原来的网站也是咱折腾了一阵子才出来的,于是决定先留着.(这个新站的评论要靠它呐~) 咱以后也会继续折腾MediaWiki,顺便在这记下来一些过程和经验呗~ 作为新博客的第一篇博文就说到这里,咱具体是怎么做的 请听下回分解 😂😂😂","tags":"Tech","title":"新的\"约伊兹的萌狼乡手札\"诞生啦~"}]}